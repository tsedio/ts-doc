{"version":3,"file":"collectionOf.js","sourceRoot":"","sources":["../../../src/decorators/collections/collectionOf.ts"],"names":[],"mappings":";;AACA,kEAA6D;AAoE7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiCG;AACH,SAAgB,YAAY,CAAC,IAAS,EAAE,cAAoB;IAC1D,MAAM,MAAM,GAAQ,EAAE,CAAC;IACvB,IAAI,QAAQ,GAAY,KAAK,CAAC;IAE9B,MAAM,SAAS,GAAG,CAAC,GAAG,IAAS,EAAE,EAAE;QACjC,MAAM,KAAK,GAAG,iCAAe,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QAC5C,gDAAgD;QAEhD,IAAI,cAAc,EAAE;YAClB,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;YACtC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;SACnC;QAED,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,qBAAqB;QACrB,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5B,2DAA2D;QAC3D,kDAAkD;QAClD,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE5B,IAAI,KAAK,CAAC,OAAO,IAAI,QAAQ,EAAE;YAC7B,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;YACxD,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;SAC9B;IACH,CAAC,CAAC;IAEF,SAAS,CAAC,QAAQ,GAAG,CAAC,QAAgB,EAAE,EAAE;QACxC,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAE3B,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,QAAQ,GAAG,CAAC,QAAgB,EAAE,EAAE;QACxC,MAAM,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAE3B,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IACF,SAAS,CAAC,aAAa,GAAG,CAAC,aAAqB,EAAE,EAAE;QAClD,MAAM,CAAC,aAAa,GAAG,aAAa,CAAC;QAErC,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,aAAa,GAAG,CAAC,aAAqB,EAAE,EAAE;QAClD,MAAM,CAAC,aAAa,GAAG,aAAa,CAAC;QAErC,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,QAAQ,GAAG,GAAG,EAAE;QACxB,QAAQ,GAAG,IAAI,CAAC;QAEhB,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,SAAS,CAAC,WAAW,GAAG,CAAC,WAAW,GAAG,IAAI,EAAE,EAAE;QAC7C,MAAM,CAAC,WAAW,GAAG,WAAW,CAAC;QAEjC,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC;AA9DD,oCA8DC;AAED;;;;GAIG;AACH,SAAgB,OAAO,CAAC,IAAS;IAC/B,OAAO,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACnC,CAAC;AAFD,0BAEC;AAED;;;;GAIG;AACH,SAAgB,KAAK,CAAC,IAAS;IAC7B,OAAO,YAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACjC,CAAC;AAFD,sBAEC","sourcesContent":["import {Type} from \"@tsed/core\";\nimport {JsonEntityStore} from \"../../domain/JsonEntityStore\";\n\nexport interface ArrayOfChainedDecorators {\n  (...args: any): any;\n\n  /**\n   * An array instance is valid against `minItems` if its size is greater than, or equal to, the value of this keyword.\n   *\n   * ::: warning\n   * The value `minItems` MUST be a non-negative integer.\n   * :::\n   *\n   * ::: tip\n   * Omitting this keyword has the same behavior as a value of 0.\n   * :::\n   */\n  MinItems(minItems: number): this;\n\n  /**\n   * The value `maxItems` MUST be a non-negative integer.\n   *\n   * An array instance is valid against `maxItems` if its size is less than, or equal to, the value of this keyword.\n   *\n   * :: warning\n   * The value `maxItems` MUST be a non-negative integer.\n   * :::\n   */\n  MaxItems(maxItems: number): this;\n\n  /**\n   * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...\n   *\n   * The array instance will be valid against \"contains\" if at least one of its elements is valid against the given schema.\n   */\n  Contains(): this;\n\n  /**\n   * If this keyword has boolean value false, the instance validates successfully. If it has boolean value true, the instance validates successfully if all of its elements are unique.\n   */\n  UniqueItems(uniqueItems: boolean): this;\n}\n\nexport interface MapOfChainedDecorators {\n  (...args: any): any;\n\n  /**\n   * An object instance is valid against `minProperties` if its number of properties is less than, or equal to, the value of this keyword.\n   *\n   * ::: warning\n   * The value of this keyword MUST be a non-negative integer.\n   * :::\n   */\n  MinProperties(minProperties: number): this;\n\n  /**\n   * An object instance is valid against `maxProperties` if its number of properties is less than, or equal to, the value of this keyword.\n   *\n   * ::: warning\n   * The value of this keyword MUST be a non-negative integer.\n   * :::\n   */\n  MaxProperties(maxProperties: number): this;\n}\n\nexport interface CollectionOfChainedDecorators extends MapOfChainedDecorators, ArrayOfChainedDecorators {\n\n}\n\n/**\n * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...\n *\n * ```typescript\n * class Model {\n *    @CollectionOf(String).MinLength(0).MaxLength(0)\n *    property: string[];\n * }\n * ```\n * ::: warning\n * You mustn't use the `type Type = string | number` as parameters Type.\n *\n * This example doesn't work:\n *\n * ```typescript\n * type Type = \"string\" | \"number\"\n * class Model {\n *    @CollectionOf(Type)\n *    property: Type[];\n * }\n * ```\n * :::\n *\n * @param {Type<any>} type\n * @param collectionType\n * @decorator\n * @ajv\n * @jsonMapper\n * @swagger\n * @schema\n * @propertyDecorator\n * @paramDecorator\n * @model\n */\nexport function CollectionOf(type: any, collectionType?: any): CollectionOfChainedDecorators {\n  const schema: any = {};\n  let contains: boolean = false;\n\n  const decorator = (...args: any) => {\n    const store = JsonEntityStore.from(...args);\n    // const itemSchema = store.itemSchema.toJSON();\n\n    if (collectionType) {\n      store.collectionType = collectionType;\n      store.schema.type(collectionType);\n    }\n\n    store.type = type;\n    // console.log(type);\n    store.itemSchema.type(type);\n    // console.log(store.itemSchema.getComputedType(), schema);\n    // store.itemSchema.assign({...itemSchema, type});\n    store.schema.assign(schema);\n\n    if (store.isArray && contains) {\n      store.schema.set(\"contains\", store.schema.get(\"items\"));\n      store.schema.delete(\"items\");\n    }\n  };\n\n  decorator.MinItems = (minItems: number) => {\n    schema.minItems = minItems;\n\n    return decorator;\n  };\n\n  decorator.MaxItems = (maxItems: number) => {\n    schema.maxItems = maxItems;\n\n    return decorator;\n  };\n  decorator.MinProperties = (minProperties: number) => {\n    schema.minProperties = minProperties;\n\n    return decorator;\n  };\n\n  decorator.MaxProperties = (maxProperties: number) => {\n    schema.maxProperties = maxProperties;\n\n    return decorator;\n  };\n\n  decorator.Contains = () => {\n    contains = true;\n\n    return decorator;\n  };\n\n  decorator.UniqueItems = (uniqueItems = true) => {\n    schema.uniqueItems = uniqueItems;\n\n    return decorator;\n  };\n\n  return decorator;\n}\n\n/**\n * Alias of @@GenericOf@@ decorator.\n * @param type\n * @decorator\n */\nexport function ArrayOf(type: any): ArrayOfChainedDecorators {\n  return CollectionOf(type, Array);\n}\n\n/**\n * Alias of @@GenericOf@@ decorator.\n * @param type\n * @decorator\n */\nexport function MapOf(type: any): MapOfChainedDecorators {\n  return CollectionOf(type, Map);\n}\n"]}