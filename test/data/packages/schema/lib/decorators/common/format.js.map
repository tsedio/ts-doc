{"version":3,"file":"format.js","sourceRoot":"","sources":["../../../src/decorators/common/format.ts"],"names":[],"mappings":";;AACA,kEAA6D;AAC7D,iDAA4C;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2EG;AACH,SAAgB,MAAM,CAAC,MAAkD;IACvE,OAAO,2BAAY,CAAC,KAAK,CAAC,EAAE;QAC1B,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;AACL,CAAC;AAJD,wBAIC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+DG;AACH,SAAgB,KAAK;IACnB,OAAO,MAAM,CAAC,iCAAe,CAAC,KAAK,CAAC,CAAC;AACvC,CAAC;AAFD,sBAEC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,SAAgB,QAAQ;IACtB,OAAO,MAAM,CAAC,iCAAe,CAAC,SAAS,CAAC,CAAC;AAC3C,CAAC;AAFD,4BAEC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,SAAgB,UAAU;IACxB,OAAO,MAAM,CAAC,iCAAe,CAAC,IAAI,CAAC,CAAC;AACtC,CAAC;AAFD,gCAEC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,SAAgB,UAAU;IACxB,OAAO,MAAM,CAAC,iCAAe,CAAC,IAAI,CAAC,CAAC;AACtC,CAAC;AAFD,gCAEC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8DG;AACH,SAAgB,GAAG;IACjB,OAAO,MAAM,CAAC,iCAAe,CAAC,GAAG,CAAC,CAAC;AACrC,CAAC;AAFD,kBAEC","sourcesContent":["import {ValueOf} from \"@tsed/core\";\nimport {JsonFormatTypes} from \"../../domain/JsonFormatTypes\";\nimport {JsonEntityFn} from \"./jsonEntityFn\";\n\n/**\n * The following formats are supported for string validation with `format` keyword:\n *\n * - **date**: full-date according to RFC3339.\n * - **time**: time with optional time-zone.\n * - **date-time**: date-time from the same source (time-zone is mandatory). date, time and date-time validate ranges in full mode and only regexp in fast mode (see options).\n * - **uri**: full uri with optional protocol.\n * - **url**: URL record.\n * - **uri-template**: URI template according to RFC6570\n * - **email**: email address.\n * - **hostname**: host name according to RFC1034.\n * - **ipv4**: IP address v4.\n * - **ipv6**: IP address v6.\n * - **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.\n * - **uuid**: Universally Unique IDentifier according to RFC4122.\n * - **json-pointer**: JSON-pointer according to RFC6901.\n * - **relative-json-pointer**: relative JSON-pointer according to this draft.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @Format(\"email\")\n *    property: string;\n * }\n * ```\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"email\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @Format(\"email\")\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"email\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * @param {string} format\n * @decorator\n * @ajv\n * @jsonMapper\n * @swagger\n * @schema\n * @propertyDecorator\n * @paramDecorator\n */\nexport function Format(format: JsonFormatTypes | ValueOf<JsonFormatTypes>) {\n  return JsonEntityFn(store => {\n    store.itemSchema.format(format);\n  });\n}\n\n/**\n * Apply an email validation on property.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @Email()\n *    property: string;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"email\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @Email()\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"email\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * > See [Format](api/common/jsonschema/schema) decorator.\n * @returns {Function}\n * @decorator\n * @ajv\n * @schema\n * @swagger\n * @model\n * @propertyDecorator\n * @paramDecorator\n */\nexport function Email() {\n  return Format(JsonFormatTypes.EMAIL);\n}\n\n/**\n * Apply a date-time validation on property.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @DateTime()\n *    property: string;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"date-time\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @DateTime()\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * > See [Format](api/common/jsonschema/schema) decorator.\n * @returns {Function}\n * @decorator\n * @ajv\n * @property\n * @parameter\n * @schema\n * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).\n */\nexport function DateTime() {\n  return Format(JsonFormatTypes.DATE_TIME);\n}\n\n/**\n * Apply a time validation on property.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @Time()\n *    property: string;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"time\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @Time()\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"time\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * > See [Format](api/common/jsonschema/schema) decorator.\n * @returns {Function}\n * @decorator\n * @ajv\n * @property\n * @parameter\n * @schema\n * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).\n */\nexport function DateFormat() {\n  return Format(JsonFormatTypes.DATE);\n}\n\n/**\n * Apply a time validation on property.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @TimeFormat()\n *    property: string;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"time\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @TimeFormat()\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"time\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * > See [Format](api/common/jsonschema/schema) decorator.\n * @returns {Function}\n * @decorator\n * @ajv\n * @property\n * @parameter\n * @schema\n * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).\n */\nexport function TimeFormat() {\n  return Format(JsonFormatTypes.TIME);\n}\n\n/**\n * Apply a uri validation on property.\n *\n * ## Example\n * ### With primitive type\n *\n * ```typescript\n * class Model {\n *    @Uri()\n *    property: string;\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"string\",\n *       \"format\": \"uri\"\n *     }\n *   }\n * }\n * ```\n *\n * ### With array type\n *\n * ```typescript\n * class Model {\n *    @Uri()\n *    @CollectionOf(String)\n *    property: string[];\n * }\n * ```\n *\n * Will produce:\n *\n * ```json\n * {\n *   \"type\": \"object\",\n *   \"properties\": {\n *     \"property\": {\n *       \"type\": \"array\",\n *       \"items\": {\n *          \"type\": \"string\",\n *          \"format\": \"uri\"\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * > See [Format](api/common/jsonschema/schema) decorator.\n * @returns {Function}\n * @decorator\n * @ajv\n * @property\n * @parameter\n * @schema\n * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).\n */\nexport function Uri() {\n  return Format(JsonFormatTypes.URI);\n}\n"]}